{
  "mlir-opt-13c6abfa: /MLIR/llvm-release/llvm-project/mlir/include/mlir/IR/StorageUniquerSupport.h:179: static ConcreteT mlir::detail::StorageUserBase<ConcreteT, BaseT, StorageT, UniquerT, Traits>::get(mlir::MLIRContext*, Args&& ...) [with Args = {mlir::Type&}; ConcreteT = mlir::emitc::LValueType; BaseT = mlir::Type; StorageT = mlir::emitc::detail::LValueTypeStorage; UniquerT = mlir::detail::TypeUniquer; Traits = {}]: Assertion `succeeded( ConcreteT::verifyInvariants(getDefaultDiagnosticEmitFn(ctx), args...))' failed.": null,
  "mlir-opt-13c6abfa: /MLIR/llvm-release/llvm-project/mlir/lib/IR/BuiltinAttributes.cpp:1346: static mlir::DenseElementsAttr mlir::DenseIntOrFPElementsAttr::getRaw(mlir::ShapedType, llvm::ArrayRef<char>): Assertion `type.hasStaticShape() && \"type must have static shape\"' failed.": null,
  "mlir-opt-13c6abfa: /MLIR/llvm-release/llvm-project/mlir/lib/Dialect/Bufferization/Transforms/OneShotModuleBufferize.cpp:137: llvm::LogicalResult {anonymous}::aliasingFuncOpBBArgsAnalysis(mlir::func::FuncOp, mlir::bufferization::OneShotAnalysisState&, mlir::bufferization::func_ext::FuncAnalysisState&): Assertion `!returnOps.empty() && \"expected at least one ReturnOp\"' failed.": null,
  "mlir-opt-13c6abfa: /MLIR/llvm-release/llvm-project/mlir/include/mlir/IR/UseDefLists.h:198: mlir::IRObjectWithUseList<OperandType>::~IRObjectWithUseList() [with OperandType = mlir::BlockOperand]: Assertion `use_empty() && \"Cannot destroy a value that still has uses!\"' failed.": null,
  "mlir-opt-13c6abfa: /MLIR/llvm-release/llvm-project/mlir/include/mlir/IR/Matchers.h:93: bool mlir::detail::constant_op_binder<AttrT>::match(mlir::Operation*) [with AttrT = mlir::Attribute]: Assertion `succeeded(result) && \"expected ConstantLike op to be foldable\"' failed.": null,
  "llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) \nSignalHandler(int) Signals.cpp:0:0\n__restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)\nraise (/lib/x86_64-linux-gnu/libc.so.6+0x4300b)\nabort (/lib/x86_64-linux-gnu/libc.so.6+0x22859)\n\n(anonymous namespace)::AllocaOpLowering::allocateBuffer(mlir::ConversionPatternRewriter&, mlir::Location, mlir::Value, mlir::Operation*) const MemRefToLLVM.cpp:0:0\nmlir::AllocLikeOpLLVMLowering::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const \nmlir::ConversionPattern::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const \nmlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const \nmlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) \n(anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0\nmlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) \nmlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) \nmlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) \n(anonymous namespace)::LowerHostCodeToLLVM::runOnOperation() ConvertLaunchFuncToLLVMCalls.cpp:0:0\nmlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) \nmlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) \nmlir::PassManager::run(mlir::Operation*) \nperformActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0\nprocessBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPoolInterface*) MlirOptMain.cpp:0:0\nllvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0\nmlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) \nmlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) \nmain \n__libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24083)\n_start": null,
  "llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) \nSignalHandler(int) Signals.cpp:0:0\n__restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)\nraise (/lib/x86_64-linux-gnu/libc.so.6+0x4300b)\nabort (/lib/x86_64-linux-gnu/libc.so.6+0x22859)\n\n(anonymous namespace)::AllocaOpLowering::allocateBuffer(mlir::ConversionPatternRewriter&, mlir::Location, mlir::Value, mlir::Operation*) const MemRefToLLVM.cpp:0:0\nmlir::AllocLikeOpLLVMLowering::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const \nmlir::ConversionPattern::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const \nmlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const \nmlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) \n(anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0\nmlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) \nmlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) \nmlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) \n(anonymous namespace)::FinalizeMemRefToLLVMConversionPass::runOnOperation() MemRefToLLVM.cpp:0:0\nmlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) \nmlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) \nmlir::PassManager::run(mlir::Operation*) \nperformActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0\nprocessBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPoolInterface*) MlirOptMain.cpp:0:0\nllvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0\nmlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) \nmlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) \nmain \n__libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24083)\n_start": null,
  "llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) \nSignalHandler(int) Signals.cpp:0:0\n__restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)\nraise (/lib/x86_64-linux-gnu/libc.so.6+0x4300b)\nabort (/lib/x86_64-linux-gnu/libc.so.6+0x22859)\n\n(anonymous namespace)::AllocaOpLowering::allocateBuffer(mlir::ConversionPatternRewriter&, mlir::Location, mlir::Value, mlir::Operation*) const MemRefToLLVM.cpp:0:0\nmlir::AllocLikeOpLLVMLowering::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const \nmlir::ConversionPattern::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const \nmlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const \nmlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) \n(anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0\nmlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) \nmlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) \nmlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) \n(anonymous namespace)::ConvertOpenMPToLLVMPass::runOnOperation() OpenMPToLLVM.cpp:0:0\nmlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) \nmlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) \nmlir::PassManager::run(mlir::Operation*) \nperformActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0\nprocessBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPoolInterface*) MlirOptMain.cpp:0:0\nllvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0\nmlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) \nmlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) \nmain \n__libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24083)\n_start": null,
  "llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) \nSignalHandler(int) Signals.cpp:0:0\n__restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)\nraise (/lib/x86_64-linux-gnu/libc.so.6+0x4300b)\nabort (/lib/x86_64-linux-gnu/libc.so.6+0x22859)\n\n(anonymous namespace)::AllocaOpLowering::allocateBuffer(mlir::ConversionPatternRewriter&, mlir::Location, mlir::Value, mlir::Operation*) const MemRefToLLVM.cpp:0:0\nmlir::AllocLikeOpLLVMLowering::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const \nmlir::ConversionPattern::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const \nmlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const \nmlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) \n(anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0\nmlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) \nmlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) \nmlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) \n(anonymous namespace)::StaticConvertToLLVM::transform(mlir::Operation*, mlir::AnalysisManager) const ConvertToLLVMPass.cpp:0:0\n(anonymous namespace)::ConvertToLLVMPass::runOnOperation() ConvertToLLVMPass.cpp:0:0\nmlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) \nmlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) \nmlir::PassManager::run(mlir::Operation*) \nperformActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0\nprocessBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPoolInterface*) MlirOptMain.cpp:0:0\nllvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0\nmlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) \nmlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) \nmain \n__libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24083)\n_start": null,
  "mlir-opt-13c6abfa: /MLIR/llvm-release/llvm-project/llvm/include/llvm/Support/Casting.h:578: decltype(auto) llvm::cast(From*) [with To = mlir::memref::AllocaScopeReturnOp; From = mlir::Operation]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"' failed.": null,
  "llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) \nSignalHandler(int) Signals.cpp:0:0\n__restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)\nraise (/lib/x86_64-linux-gnu/libc.so.6+0x4300b)\nabort (/lib/x86_64-linux-gnu/libc.so.6+0x22859)\n\n(anonymous namespace)::AllocaOpLowering::allocateBuffer(mlir::ConversionPatternRewriter&, mlir::Location, mlir::Value, mlir::Operation*) const MemRefToLLVM.cpp:0:0\nmlir::AllocLikeOpLLVMLowering::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const \nmlir::ConversionPattern::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const \nmlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const \nmlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) \n(anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0\nmlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) \nmlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) \nmlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) \n(anonymous namespace)::GpuToLLVMConversionPass::runOnOperation() GPUToLLVMConversion.cpp:0:0\nmlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) \nmlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) \nmlir::PassManager::run(mlir::Operation*) \nperformActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0\nprocessBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPoolInterface*) MlirOptMain.cpp:0:0\nllvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0\nmlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) \nmlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) \nmain \n__libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24083)\n_start": null,
  "mlir-opt-13c6abfa: /MLIR/llvm-release/llvm-project/llvm/include/llvm/ADT/APInt.h:120: llvm::APInt::APInt(unsigned int, uint64_t, bool, bool): Assertion `llvm::isIntN(BitWidth, val) && \"Value is not an N-bit signed value\"' failed.": null,
  "mlir-opt-13c6abfa: /MLIR/llvm-release/llvm-project/build/tools/mlir/include/mlir/IR/BuiltinTypeInterfaces.h.inc:309: bool mlir::detail::ShapedTypeTrait<ConcreteType>::isDynamicDim(unsigned int) const [with ConcreteType = mlir::RankedTensorType]: Assertion `idx < getRank() && \"invalid index for shaped type\"' failed.": null,
  "mlir-opt-13c6abfa: /MLIR/llvm-release/llvm-project/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From&) [with To = mlir::IntegerAttr; From = mlir::Attribute]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"' failed.": null,
  "llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) \nSignalHandler(int) Signals.cpp:0:0\n__restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)\nmlir::linalg::detail::isContractionBody(mlir::Block&, llvm::function_ref<bool (mlir::Operation*, mlir::Operation*)>, llvm::raw_ostream&) \nmlir::linalg::detail::isContractionInterfaceImpl(mlir::Operation*, mlir::linalg::ContractionDimensions*) \nmlir::linalg::isaContractionOpInterface(mlir::linalg::LinalgOp) \nmlir::linalg::specializeGenericOp(mlir::RewriterBase&, mlir::linalg::GenericOp) \nmlir::linalg::LinalgSpecializationPattern::matchAndRewrite(mlir::linalg::GenericOp, mlir::PatternRewriter&) const \nmlir::detail::OpOrInterfaceRewritePatternBase<mlir::linalg::GenericOp>::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const \nmlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) \n(anonymous namespace)::GreedyPatternRewriteDriver::processWorklist() GreedyPatternRewriteDriver.cpp:0:0\nmlir::applyPatternsGreedily(mlir::Region&, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig, bool*) \n(anonymous namespace)::LinalgSpecializeGenericOpsPass::runOnOperation() Specialize.cpp:0:0\nmlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) \nmlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) \nmlir::PassManager::run(mlir::Operation*) \nperformActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0\nprocessBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPoolInterface*) MlirOptMain.cpp:0:0\nllvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0\nmlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) \nmlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) \nmain \n__libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24083)\n_start": null,
  "llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) \nSignalHandler(int) Signals.cpp:0:0\n__restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)\nmlir::linalg::detail::isContractionBody(mlir::Block&, llvm::function_ref<bool (mlir::Operation*, mlir::Operation*)>, llvm::raw_ostream&) \nmlir::linalg::detail::isContractionInterfaceImpl(mlir::Operation*, mlir::linalg::ContractionDimensions*) \nmlir::linalg::isaContractionOpInterface(mlir::linalg::LinalgOp) \n(anonymous namespace)::BlockPackMatmul<mlir::linalg::GenericOp>::matchAndRewrite(mlir::linalg::GenericOp, mlir::PatternRewriter&) const BlockPackMatmul.cpp:0:0\nmlir::detail::OpOrInterfaceRewritePatternBase<mlir::linalg::GenericOp>::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const \nmlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) \n(anonymous namespace)::GreedyPatternRewriteDriver::processWorklist() GreedyPatternRewriteDriver.cpp:0:0\nmlir::applyPatternsGreedily(mlir::Region&, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig, bool*) \n(anonymous namespace)::LinalgBlockPackMatmul::runOnOperation() BlockPackMatmul.cpp:0:0\nmlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) \nmlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) \nmlir::PassManager::run(mlir::Operation*) \nperformActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0\nprocessBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPoolInterface*) MlirOptMain.cpp:0:0\nllvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0\nmlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) \nmlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) \nmain \n__libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24083)\n_start": null,
  "llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) \nSignalHandler(int) Signals.cpp:0:0\n__restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)\n_ZSt9__find_ifIN4mlir17ValueTypeIteratorIN4llvm6detail27indexed_accessor_range_baseINS0_12OperandRangeEPNS0_9OpOperandENS0_5ValueES8_S8_E8iteratorEEEN9__gnu_cxx5__ops12_Iter_negateIZNKS0_13TypeConverter7isLegalINS0_14ValueTypeRangeIS5_EEEENSt9enable_ifIXaantsrSt14is_convertibleIT_NS0_4TypeEE5valuentsrSK_ISL_PNS0_9OperationEE5valueEbE4typeEOSL_EUlSM_E_EEESL_SL_SL_T0_St26random_access_iterator_tag \nmlir::TypeConverter::isLegal(mlir::Operation*) const \nstd::_Function_handler<std::optional<bool> (mlir::Operation*), (anonymous namespace)::EmulateWideIntPass::runOnOperation()::'lambda0'(mlir::Operation*)>::_M_invoke(std::_Any_data const&, mlir::Operation*&&) EmulateWideInt.cpp:0:0\nmlir::ConversionTarget::isLegal(mlir::Operation*) const \n(anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0\nmlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) \nmlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) \nmlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) \n(anonymous namespace)::EmulateWideIntPass::runOnOperation() EmulateWideInt.cpp:0:0\nmlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) \nmlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) \nmlir::PassManager::run(mlir::Operation*) \nperformActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0\nprocessBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPoolInterface*) MlirOptMain.cpp:0:0\nllvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0\nmlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) \nmlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) \nmlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) \nmain \n__libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24083)\n_start": null
}